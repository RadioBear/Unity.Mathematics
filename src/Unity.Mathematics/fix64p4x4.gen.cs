//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.CompilerServices;

#pragma warning disable 0660, 0661

namespace Unity.Mathematics
{
    [System.Serializable]
    public partial struct fix64p4x4 : System.IEquatable<fix64p4x4>, IFormattable
    {
        public fix64p4 c0;
        public fix64p4 c1;
        public fix64p4 c2;
        public fix64p4 c3;


        /// <summary>Constructs a fix64p4x4 matrix from four fix64p4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public fix64p4x4(fix64p4 c0, fix64p4 c1, fix64p4 c2, fix64p4 c3)
        { 
            this.c0 = c0;
            this.c1 = c1;
            this.c2 = c2;
            this.c3 = c3;
        }

        /// <summary>Constructs a fix64p4x4 matrix from 16 fix64p values given in row-major order.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public fix64p4x4(fix64p m00, fix64p m01, fix64p m02, fix64p m03,
                         fix64p m10, fix64p m11, fix64p m12, fix64p m13,
                         fix64p m20, fix64p m21, fix64p m22, fix64p m23,
                         fix64p m30, fix64p m31, fix64p m32, fix64p m33)
        { 
            this.c0 = new fix64p4(m00, m10, m20, m30);
            this.c1 = new fix64p4(m01, m11, m21, m31);
            this.c2 = new fix64p4(m02, m12, m22, m32);
            this.c3 = new fix64p4(m03, m13, m23, m33);
        }

        /// <summary>Constructs a fix64p4x4 matrix from a single fix64p value by assigning it to every component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public fix64p4x4(fix64p v)
        {
            this.c0 = v;
            this.c1 = v;
            this.c2 = v;
            this.c3 = v;
        }


        /// <summary>Implicitly converts a single fix64p value to a fix64p4x4 matrix by assigning it to every component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator fix64p4x4(fix64p v) { return new fix64p4x4(v); }


        /// <summary>Returns the result of a componentwise multiplication operation on two fix64p4x4 matrices.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 operator * (fix64p4x4 lhs, fix64p4x4 rhs) { return new fix64p4x4 (lhs.c0 * rhs.c0, lhs.c1 * rhs.c1, lhs.c2 * rhs.c2, lhs.c3 * rhs.c3); }

        /// <summary>Returns the result of a componentwise multiplication operation on a fix64p4x4 matrix and a fix64p value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 operator * (fix64p4x4 lhs, fix64p rhs) { return new fix64p4x4 (lhs.c0 * rhs, lhs.c1 * rhs, lhs.c2 * rhs, lhs.c3 * rhs); }

        /// <summary>Returns the result of a componentwise multiplication operation on a fix64p value and a fix64p4x4 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 operator * (fix64p lhs, fix64p4x4 rhs) { return new fix64p4x4 (lhs * rhs.c0, lhs * rhs.c1, lhs * rhs.c2, lhs * rhs.c3); }


        /// <summary>Returns the result of a componentwise addition operation on two fix64p4x4 matrices.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 operator + (fix64p4x4 lhs, fix64p4x4 rhs) { return new fix64p4x4 (lhs.c0 + rhs.c0, lhs.c1 + rhs.c1, lhs.c2 + rhs.c2, lhs.c3 + rhs.c3); }

        /// <summary>Returns the result of a componentwise addition operation on a fix64p4x4 matrix and a fix64p value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 operator + (fix64p4x4 lhs, fix64p rhs) { return new fix64p4x4 (lhs.c0 + rhs, lhs.c1 + rhs, lhs.c2 + rhs, lhs.c3 + rhs); }

        /// <summary>Returns the result of a componentwise addition operation on a fix64p value and a fix64p4x4 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 operator + (fix64p lhs, fix64p4x4 rhs) { return new fix64p4x4 (lhs + rhs.c0, lhs + rhs.c1, lhs + rhs.c2, lhs + rhs.c3); }


        /// <summary>Returns the result of a componentwise subtraction operation on two fix64p4x4 matrices.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 operator - (fix64p4x4 lhs, fix64p4x4 rhs) { return new fix64p4x4 (lhs.c0 - rhs.c0, lhs.c1 - rhs.c1, lhs.c2 - rhs.c2, lhs.c3 - rhs.c3); }

        /// <summary>Returns the result of a componentwise subtraction operation on a fix64p4x4 matrix and a fix64p value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 operator - (fix64p4x4 lhs, fix64p rhs) { return new fix64p4x4 (lhs.c0 - rhs, lhs.c1 - rhs, lhs.c2 - rhs, lhs.c3 - rhs); }

        /// <summary>Returns the result of a componentwise subtraction operation on a fix64p value and a fix64p4x4 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 operator - (fix64p lhs, fix64p4x4 rhs) { return new fix64p4x4 (lhs - rhs.c0, lhs - rhs.c1, lhs - rhs.c2, lhs - rhs.c3); }


        /// <summary>Returns the result of a componentwise division operation on two fix64p4x4 matrices.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 operator / (fix64p4x4 lhs, fix64p4x4 rhs) { return new fix64p4x4 (lhs.c0 / rhs.c0, lhs.c1 / rhs.c1, lhs.c2 / rhs.c2, lhs.c3 / rhs.c3); }

        /// <summary>Returns the result of a componentwise division operation on a fix64p4x4 matrix and a fix64p value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 operator / (fix64p4x4 lhs, fix64p rhs) { return new fix64p4x4 (lhs.c0 / rhs, lhs.c1 / rhs, lhs.c2 / rhs, lhs.c3 / rhs); }

        /// <summary>Returns the result of a componentwise division operation on a fix64p value and a fix64p4x4 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 operator / (fix64p lhs, fix64p4x4 rhs) { return new fix64p4x4 (lhs / rhs.c0, lhs / rhs.c1, lhs / rhs.c2, lhs / rhs.c3); }


        /// <summary>Returns the result of a componentwise modulus operation on two fix64p4x4 matrices.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 operator % (fix64p4x4 lhs, fix64p4x4 rhs) { return new fix64p4x4 (lhs.c0 % rhs.c0, lhs.c1 % rhs.c1, lhs.c2 % rhs.c2, lhs.c3 % rhs.c3); }

        /// <summary>Returns the result of a componentwise modulus operation on a fix64p4x4 matrix and a fix64p value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 operator % (fix64p4x4 lhs, fix64p rhs) { return new fix64p4x4 (lhs.c0 % rhs, lhs.c1 % rhs, lhs.c2 % rhs, lhs.c3 % rhs); }

        /// <summary>Returns the result of a componentwise modulus operation on a fix64p value and a fix64p4x4 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 operator % (fix64p lhs, fix64p4x4 rhs) { return new fix64p4x4 (lhs % rhs.c0, lhs % rhs.c1, lhs % rhs.c2, lhs % rhs.c3); }


        /// <summary>Returns the result of a componentwise increment operation on a fix64p4x4 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 operator ++ (fix64p4x4 val) { return new fix64p4x4 (++val.c0, ++val.c1, ++val.c2, ++val.c3); }


        /// <summary>Returns the result of a componentwise decrement operation on a fix64p4x4 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 operator -- (fix64p4x4 val) { return new fix64p4x4 (--val.c0, --val.c1, --val.c2, --val.c3); }


        /// <summary>Returns the result of a componentwise less than operation on two fix64p4x4 matrices.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool4x4 operator < (fix64p4x4 lhs, fix64p4x4 rhs) { return new bool4x4 (lhs.c0 < rhs.c0, lhs.c1 < rhs.c1, lhs.c2 < rhs.c2, lhs.c3 < rhs.c3); }

        /// <summary>Returns the result of a componentwise less than operation on a fix64p4x4 matrix and a fix64p value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool4x4 operator < (fix64p4x4 lhs, fix64p rhs) { return new bool4x4 (lhs.c0 < rhs, lhs.c1 < rhs, lhs.c2 < rhs, lhs.c3 < rhs); }

        /// <summary>Returns the result of a componentwise less than operation on a fix64p value and a fix64p4x4 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool4x4 operator < (fix64p lhs, fix64p4x4 rhs) { return new bool4x4 (lhs < rhs.c0, lhs < rhs.c1, lhs < rhs.c2, lhs < rhs.c3); }


        /// <summary>Returns the result of a componentwise less or equal operation on two fix64p4x4 matrices.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool4x4 operator <= (fix64p4x4 lhs, fix64p4x4 rhs) { return new bool4x4 (lhs.c0 <= rhs.c0, lhs.c1 <= rhs.c1, lhs.c2 <= rhs.c2, lhs.c3 <= rhs.c3); }

        /// <summary>Returns the result of a componentwise less or equal operation on a fix64p4x4 matrix and a fix64p value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool4x4 operator <= (fix64p4x4 lhs, fix64p rhs) { return new bool4x4 (lhs.c0 <= rhs, lhs.c1 <= rhs, lhs.c2 <= rhs, lhs.c3 <= rhs); }

        /// <summary>Returns the result of a componentwise less or equal operation on a fix64p value and a fix64p4x4 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool4x4 operator <= (fix64p lhs, fix64p4x4 rhs) { return new bool4x4 (lhs <= rhs.c0, lhs <= rhs.c1, lhs <= rhs.c2, lhs <= rhs.c3); }


        /// <summary>Returns the result of a componentwise greater than operation on two fix64p4x4 matrices.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool4x4 operator > (fix64p4x4 lhs, fix64p4x4 rhs) { return new bool4x4 (lhs.c0 > rhs.c0, lhs.c1 > rhs.c1, lhs.c2 > rhs.c2, lhs.c3 > rhs.c3); }

        /// <summary>Returns the result of a componentwise greater than operation on a fix64p4x4 matrix and a fix64p value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool4x4 operator > (fix64p4x4 lhs, fix64p rhs) { return new bool4x4 (lhs.c0 > rhs, lhs.c1 > rhs, lhs.c2 > rhs, lhs.c3 > rhs); }

        /// <summary>Returns the result of a componentwise greater than operation on a fix64p value and a fix64p4x4 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool4x4 operator > (fix64p lhs, fix64p4x4 rhs) { return new bool4x4 (lhs > rhs.c0, lhs > rhs.c1, lhs > rhs.c2, lhs > rhs.c3); }


        /// <summary>Returns the result of a componentwise greater or equal operation on two fix64p4x4 matrices.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool4x4 operator >= (fix64p4x4 lhs, fix64p4x4 rhs) { return new bool4x4 (lhs.c0 >= rhs.c0, lhs.c1 >= rhs.c1, lhs.c2 >= rhs.c2, lhs.c3 >= rhs.c3); }

        /// <summary>Returns the result of a componentwise greater or equal operation on a fix64p4x4 matrix and a fix64p value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool4x4 operator >= (fix64p4x4 lhs, fix64p rhs) { return new bool4x4 (lhs.c0 >= rhs, lhs.c1 >= rhs, lhs.c2 >= rhs, lhs.c3 >= rhs); }

        /// <summary>Returns the result of a componentwise greater or equal operation on a fix64p value and a fix64p4x4 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool4x4 operator >= (fix64p lhs, fix64p4x4 rhs) { return new bool4x4 (lhs >= rhs.c0, lhs >= rhs.c1, lhs >= rhs.c2, lhs >= rhs.c3); }


        /// <summary>Returns the result of a componentwise unary minus operation on a fix64p4x4 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 operator - (fix64p4x4 val) { return new fix64p4x4 (-val.c0, -val.c1, -val.c2, -val.c3); }


        /// <summary>Returns the result of a componentwise unary plus operation on a fix64p4x4 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 operator + (fix64p4x4 val) { return new fix64p4x4 (+val.c0, +val.c1, +val.c2, +val.c3); }


        /// <summary>Returns the result of a componentwise equality operation on two fix64p4x4 matrices.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool4x4 operator == (fix64p4x4 lhs, fix64p4x4 rhs) { return new bool4x4 (lhs.c0 == rhs.c0, lhs.c1 == rhs.c1, lhs.c2 == rhs.c2, lhs.c3 == rhs.c3); }

        /// <summary>Returns the result of a componentwise equality operation on a fix64p4x4 matrix and a fix64p value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool4x4 operator == (fix64p4x4 lhs, fix64p rhs) { return new bool4x4 (lhs.c0 == rhs, lhs.c1 == rhs, lhs.c2 == rhs, lhs.c3 == rhs); }

        /// <summary>Returns the result of a componentwise equality operation on a fix64p value and a fix64p4x4 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool4x4 operator == (fix64p lhs, fix64p4x4 rhs) { return new bool4x4 (lhs == rhs.c0, lhs == rhs.c1, lhs == rhs.c2, lhs == rhs.c3); }


        /// <summary>Returns the result of a componentwise not equal operation on two fix64p4x4 matrices.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool4x4 operator != (fix64p4x4 lhs, fix64p4x4 rhs) { return new bool4x4 (lhs.c0 != rhs.c0, lhs.c1 != rhs.c1, lhs.c2 != rhs.c2, lhs.c3 != rhs.c3); }

        /// <summary>Returns the result of a componentwise not equal operation on a fix64p4x4 matrix and a fix64p value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool4x4 operator != (fix64p4x4 lhs, fix64p rhs) { return new bool4x4 (lhs.c0 != rhs, lhs.c1 != rhs, lhs.c2 != rhs, lhs.c3 != rhs); }

        /// <summary>Returns the result of a componentwise not equal operation on a fix64p value and a fix64p4x4 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool4x4 operator != (fix64p lhs, fix64p4x4 rhs) { return new bool4x4 (lhs != rhs.c0, lhs != rhs.c1, lhs != rhs.c2, lhs != rhs.c3); }



        /// <summary>Returns the fix64p4 element at a specified index.</summary>
        unsafe public ref fix64p4 this[int index]
        {
            get
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                if ((uint)index >= 4)
                    throw new System.ArgumentException("index must be between[0...3]");
#endif
                fixed (fix64p4x4* array = &this) { return ref ((fix64p4*)array)[index]; }
            }
        }

        /// <summary>Returns true if the fix64p4x4 is equal to a given fix64p4x4, false otherwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(fix64p4x4 rhs) { return c0.Equals(rhs.c0) && c1.Equals(rhs.c1) && c2.Equals(rhs.c2) && c3.Equals(rhs.c3); }

        /// <summary>Returns true if the fix64p4x4 is equal to a given fix64p4x4, false otherwise.</summary>
        public override bool Equals(object o) { return Equals((fix64p4x4)o); }


        /// <summary>Returns a hash code for the fix64p4x4.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override int GetHashCode() { return (int)math.hash(this); }


        /// <summary>Returns a string representation of the fix64p4x4.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override string ToString()
        {
            return string.Format("fix64p4x4({0}, {1}, {2}, {3},  {4}, {5}, {6}, {7},  {8}, {9}, {10}, {11},  {12}, {13}, {14}, {15})", c0.x, c1.x, c2.x, c3.x, c0.y, c1.y, c2.y, c3.y, c0.z, c1.z, c2.z, c3.z, c0.w, c1.w, c2.w, c3.w);
        }

        /// <summary>Returns a string representation of the fix64p4x4 using a specified format and culture-specific format information.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public string ToString(string format, IFormatProvider formatProvider)
        {
            return string.Format("fix64p4x4({0}, {1}, {2}, {3},  {4}, {5}, {6}, {7},  {8}, {9}, {10}, {11},  {12}, {13}, {14}, {15})", c0.x.ToString(format, formatProvider), c1.x.ToString(format, formatProvider), c2.x.ToString(format, formatProvider), c3.x.ToString(format, formatProvider), c0.y.ToString(format, formatProvider), c1.y.ToString(format, formatProvider), c2.y.ToString(format, formatProvider), c3.y.ToString(format, formatProvider), c0.z.ToString(format, formatProvider), c1.z.ToString(format, formatProvider), c2.z.ToString(format, formatProvider), c3.z.ToString(format, formatProvider), c0.w.ToString(format, formatProvider), c1.w.ToString(format, formatProvider), c2.w.ToString(format, formatProvider), c3.w.ToString(format, formatProvider));
        }

    }

    public static partial class math
    {
        /// <summary>Returns a fix64p4x4 matrix constructed from four fix64p4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 fix64p4x4(fix64p4 c0, fix64p4 c1, fix64p4 c2, fix64p4 c3) { return new fix64p4x4(c0, c1, c2, c3); }

        /// <summary>Returns a fix64p4x4 matrix constructed from from 16 fix64p values given in row-major order.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 fix64p4x4(fix64p m00, fix64p m01, fix64p m02, fix64p m03,
                                          fix64p m10, fix64p m11, fix64p m12, fix64p m13,
                                          fix64p m20, fix64p m21, fix64p m22, fix64p m23,
                                          fix64p m30, fix64p m31, fix64p m32, fix64p m33)
        {
            return new fix64p4x4(m00, m01, m02, m03,
                                 m10, m11, m12, m13,
                                 m20, m21, m22, m23,
                                 m30, m31, m32, m33);
        }

        /// <summary>Returns a fix64p4x4 matrix constructed from a single fix64p value by assigning it to every component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 fix64p4x4(fix64p v) { return new fix64p4x4(v); }

        /// <summary>Return the fix64p4x4 transpose of a fix64p4x4 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static fix64p4x4 transpose(fix64p4x4 v)
        {
            return fix64p4x4(
                v.c0.x, v.c0.y, v.c0.z, v.c0.w,
                v.c1.x, v.c1.y, v.c1.z, v.c1.w,
                v.c2.x, v.c2.y, v.c2.z, v.c2.w,
                v.c3.x, v.c3.y, v.c3.z, v.c3.w);
        }

        /// <summary>Returns a uint hash code of a fix64p4x4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint hash(fix64p4x4 v)
        {
            return csum(fold_to_uint(v.c0) * uint4(0x48125549u, 0xEEE2123Bu, 0xE3AD9FE5u, 0xCE1CF8BFu) + 
                        fold_to_uint(v.c1) * uint4(0x7BE39F3Bu, 0xFAB9913Fu, 0xB4501269u, 0xE04B89FDu) + 
                        fold_to_uint(v.c2) * uint4(0xDB3DE101u, 0x7B6D1B4Bu, 0x58399E77u, 0x5EAC29C9u) + 
                        fold_to_uint(v.c3) * uint4(0xFC6014F9u, 0x6BF6693Fu, 0x9D1B1D9Bu, 0xF842F5C1u)) + 0xA47EC335u;
        }

        /// <summary>
        /// Returns a uint4 vector hash code of a fix64p4x4 vector.
        /// When multiple elements are to be hashes together, it can more efficient to calculate and combine wide hash
        /// that are only reduced to a narrow uint hash at the very end instead of at every step.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint4 hashwide(fix64p4x4 v)
        {
            return (fold_to_uint(v.c0) * uint4(0xA477DF57u, 0xC4B1493Fu, 0xBA0966D3u, 0xAFBEE253u) + 
                    fold_to_uint(v.c1) * uint4(0x5B419C01u, 0x515D90F5u, 0xEC9F68F3u, 0xF9EA92D5u) + 
                    fold_to_uint(v.c2) * uint4(0xC2FAFCB9u, 0x616E9CA1u, 0xC5C5394Bu, 0xCAE78587u) + 
                    fold_to_uint(v.c3) * uint4(0x7A1541C9u, 0xF83BD927u, 0x6A243BCBu, 0x509B84C9u)) + 0x91D13847u;
        }

    }
}
